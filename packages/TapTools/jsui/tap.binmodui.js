/* * tap.binmodui.js		 * User Interface for tap.fft.binmodulator * by Jesse Allison & Tim Place * Copyright © 2005 Electrotap, L.L.C. * */// loadbang function added by Tim on 2005.02.28// much re-writting to get it working properly by Tim on 2005.03.10// Tim re-organized some of the discombolutated code on 2005.07.19//	then re-wrote pattr stuff on 2005.07.19/******************************************************************* * SETUP *******************************************************************/// CONSTANTSconst BINMODUI_VERSION = 2;const MODE_SPLINE = 0;const MODE_CLICK = 1;const MODE_SQUARE = 2;// GLOBALS: INTERNALvar boxWidth = box.rect[2] - box.rect[0];var boxHeight = box.rect[3] - box.rect[1];var aspect = boxWidth / boxHeight;var world = [0, 0];		// world coord of mouse eventvar pixel = [0, 0];		// pixel coord of mouse eventvar splineX = [(-aspect + 0.1), 0, (aspect - 0.1)]; 	// Declare array of spline point positions in World Coords -1:y:1, -aspect:x:aspectvar splineY = [0, 0.1, 0.5];var squareX = [(-aspect + 0.1), 0.5, (aspect - 0.1)];	// array of square wave positionsvar squareY = [0.1, 0.1, 0.5];var squareDeviation = squareY[1] - squareY[0];			// height/depth of wavevar squareWidth = squareX[1] - squareX[0];				// pulse width of square wavevar clickableY = new Array();var divisionWorld;										// width of one division in world coordsvar widthWorld;											// width of 1 pulse between outer ballsvar pixelWidth;var handleSelected = 0;									// which handle was selectedvar shift = (0.1 / (aspect * 2)) * boxWidth;			// pixel width of 0.1 world// GLOBALS: OBJECT DATAvar vbrgb = [0.55294, 0.70588, 0.49412, 0.2];	// Colors...var vfrgb = [0.1, 0.5, 0.2, 1.0];var handlergb = [0.2, 0.6, 0.3, 1.0];var mode = MODE_SPLINE;							// 0=spline, 1=clickable modes, 2=toggles, var multiplier = 1.0;var y1, x2, y2, y3;								// HANDLE POSITIONS (ADDED BY TAP)var poll_resolution = 64;var poll = new Array();							// polling output value of each bin// CONFIGURATIONsketch.default2d();inlets = 6;outlets = 6;// INITIALIZATIONfunction loadbang(){	// set up assistance strings	setinletassist(0, "various input, and lists");	setinletassist(1, "(symbol) mode");	setinletassist(2, "(float) y1");	setinletassist(3, "(float) x2");	setinletassist(4, "(float) y2");	setinletassist(5, "(float) y3");		setoutletassist(0, "(list) value for each LFO");	setoutletassist(1, "(symbol) mode");	setoutletassist(2, "(float) y1");	setoutletassist(3, "(float) x2");	setoutletassist(4, "(float) y2");	setoutletassist(5, "(float) y3");	for(i = 0; i < poll_resolution; i ++) {			// set clickableY values to half 0:1		clickableY[i] = 0.5;		poll[i] = 0.5;	}		divisionWorld = (2 * aspect) / poll_resolution;		widthWorld = (squareX[2] - squareX[0]) / poll_resolution;	pixelWidth = boxWidth / poll_resolution;	 	// Process Arguments		if(jsarguments.length > 1)		multiplier = jsarguments[1];	draw();}/******************************************************************* * METHODS *******************************************************************/ // METHOD: bang inputfunction bang(){	draw();	poll_position();}function poll_position(){	var curvy = 0.;	var splineOriginalColor = vbrgb[1];		// compare to the pixel color	var pixelColorToCompare = [0,0,0];		// color to compare to the foreground color.	var i = 0;	var yPos = boxHeight / 2;	var xPos = 0;	var YOffset = 0;	var withinScreen = 1;		if(mode == MODE_CLICK){							// Clickable		for (i=0; i < poll_resolution; i++) {			poll[i] = clickableY[i] * multiplier;		}	} 	else if(mode == MODE_SQUARE){					// Square Wave		for (i=0; i < poll_resolution; i++) {			clickableY[i] = poll[i];			poll[i] = poll[i] * multiplier;		}	} 	else {											// Spline			for (i=0;i<poll_resolution;i++) {			xPos = shift + (((boxWidth - (shift * 2)) / poll_resolution) * (i + 1));						if (withinScreen == 1) {	// only check for spline if it is still within the screen				withinScreen = 0; 	// set the withinScreen flag to negative only considered within if the spline is detected and break acheived.				for(YOffset = 0; YOffset < (boxHeight); YOffset++) {				// cycle through Y pixels YPos +/- the yOffset untill you find the pixel										pixelColorToCompare = sketch.getpixel(xPos, (Math.min(yPos + YOffset,(boxHeight - 1))));		// the color of a pixel										// post(yPos, YOffset, "\n");									// post("color ", pixelColorToCompare[0], splineOriginalColor);										if(pixelColorToCompare[1] < splineOriginalColor) {	// if it's the right color, set the output and break;									// post("color ", pixelColorToCompare[1], splineOriginalColor);												yPos = (Math.min(yPos + YOffset,(boxHeight - 1)));						curvy = 1 - (yPos / boxHeight);  				// invert the Y axis and assign it for output.									// sketch.setpixel(xPos, yPos, 0,0,1,1);  // only used for testing.									// post(i, "curvy ", curvy, "yPos ", yPos, "\n");						withinScreen = 1;  // the spline is still within the screen						break;					}										pixelColorToCompare = sketch.getpixel(xPos, (Math.max(yPos - YOffset,0.)));		// the color of a pixel										if(pixelColorToCompare[1] < splineOriginalColor) {	// if it's the right color, set the output and break;									// post("color ", pixelColorToCompare[1], splineOriginalColor);						yPos = (Math.max(yPos - YOffset,0.));						curvy = 1 - (yPos / boxHeight);  // invert the Y axis and assign it for output.									// sketch.setpixel(xPos, yPos, 0.8,0,0.8,1);  // only used for testing.									// post(i, "curvy ", curvy, "yPos ", yPos, "\n");						withinScreen = 1;	// The spline is still within the screen						break;					}										// sketch.setpixel(xPos, yPos, 1,0,0,1);  // only used for testing - useful -				}							} else {			// if the spline went off screen, only check to see if it came back.							curvy = 1 - (yPos / boxHeight);		// keeps the curvy the same until the spline returns								pixelColorToCompare = sketch.getpixel(xPos,yPos);								if(pixelColorToCompare[1] < splineOriginalColor) {	// if it's the right color, set the output and break;					withinScreen = 1;	// the spline returned				}			}						poll[i] = (curvy * multiplier);				// calculate and assign value for each bin.			clickableY[i] = curvy;		}	}	outlet(0, poll);	notifyclients();}function msg_int(value){	if(inlet == 1){		mode = value;		bang();	}}function controlmode(value){	if(value == "curve")		mode = MODE_SPLINE;	else if(value == "square")		mode = MODE_SQUARE;	else if(value == "clickable")		mode = MODE_CLICK;	bang();}function outputMultiplier(v){	multiplier = v;}function list(){	if(mode == MODE_CLICK){		// if clickable, then set each value, otherwise ignore		for (var i=0; i< poll_resolution; i++) {			clickableY[i] = arguments[i] / multiplier;		}	}	draw();	notifyclients();}function msg_float(value){	if(inlet == 2){		if(value == y1) return;		y1 = value;	}	else if(inlet == 3){		if(value == x2) return;		x2 = value;	}	else if(inlet == 4){		if(value == y2) return;		y2 = value;	}	else if(inlet == 5){		if(value == y3) return;		y3 = value;	}		process_handles();}function process_handles(){	if(mode == MODE_SPLINE){		calc_curve();	}	else if(mode == MODE_SQUARE){		calc_square();	}}function calc_square(){	squareX[1] = Math.min(Math.max(squareX[0], (x2 * aspect)), squareX[2]);	squareY[0] = Math.min(Math.max(-1.0, y1), 1.0);	squareY[1] = Math.min(Math.max(-1.0, y2), 1.0);	squareY[2] = Math.min(Math.max(-1.0, y3), 1.0);		calculateSquare();	poll_position();	draw();}function calculateSquare(){	squareDeviation = squareY[1] - squareY[0];				// height/depth of wave	squareWidth = Math.max(squareX[1] - squareX[0], 0.01);	// pulse width of square wave		outlet(1, (squareX[1] / aspect), squareY);}function calc_curve(){	splineX[1] = Math.min(Math.max(splineX[0], (x2 * aspect)), splineX[2]);	splineY[0] = Math.min(Math.max(-1.0, y1), 1.0);	splineY[1] = Math.min(Math.max(-1.0, y2), 1.0);	splineY[2] = Math.min(Math.max(-1.0, y3), 1.0);		poll_position();	draw();	}function send_handles(){	if(mode == MODE_SPLINE){		y1 = splineY[0];		x2 = splineX[1] / aspect;		y2 = splineY[1];		y3 = splineY[2];	}	else if(mode == MODE_SQUARE){		y1 = squareY[0];		x2 = squareX[1] / aspect;		y2 = squareY[1];		y3 = squareY[2];	}	else return;		outlet(2, y1);	outlet(3, x2);	outlet(4, y2);	outlet(5, y3);}/********************************************************************* * Drawing *********************************************************************/function draw(){	var i;		// declare variables		sketch.glclearcolor(vbrgb);		// Clear Background	sketch.glclear();		// draw line for edges?		switch(mode){		case MODE_SPLINE:							// spline			with(sketch){											moveto(splineX[0],splineY[0]);		// Draw handles				glcolor(handlergb);				circle(0.05);				moveto(splineX[1],splineY[1]);				circle(0.05);				moveto(splineX[2],splineY[2]);				circle(0.05);								beginstroke("basic2d");				// Draw spline					strokeparam("slices",80);				strokeparam("outcolor",0,0,0,1.0);				strokeparam("color",vfrgb);				strokeparam("scale",0.01);				strokepoint(splineX[0],splineY[0]);				//strokeparam("scale",0.1);				strokepoint(splineX[1],splineY[1]);				//strokeparam("scale",0);				strokepoint(splineX[2],splineY[2]);				endstroke();				}			send_handles();			break;					case MODE_SQUARE:						// toggles Square Wave			numPulses = Math.ceil((squareX[2] - squareX[0]) / squareWidth) + 1;			var slope = (squareY[2] - squareY[0]) / (squareX[2] - squareX[0]);			var currentX = 0;			// current x position while making square wave			var xVal = squareX[0];				// cliped x value			var yValHigh = 0.;			var yValLow = 0.;			var yDeviationHigh = (squareY[0] + squareDeviation);			var yDeviationLow = (squareY[0] - squareDeviation);			var lastBin = 0;			var bin = 0;			var binShift = (0. - squareX[0]);  			// how much to shift x value before calculating bin number				with(sketch){							moveto(squareX[0],squareY[0]);			// Draw handles				glcolor(handlergb);				circle(0.05);				moveto(squareX[1],squareY[1]);				circle(0.05);				moveto(squareX[2],squareY[2]);				circle(0.05);								glcolor(vfrgb);								moveto(squareX[0],squareY[0]);						// start at left side ball								for (i = 1; i < numPulses; i++) {				// one loop for every cycle					currentX = (i * squareWidth);				// what the current X position is						// draw upper line										yValHigh = Math.min(Math.max(-1., ((slope * currentX) + yDeviationHigh)), 1.);		// find y value at beginning of high pulse					yValLow = Math.min(Math.max(-1., ((slope * currentX) + yDeviationLow)), 1.);		// find y value at beginning of low pulse					lineto(xVal, yValHigh);																// line to high side										xVal = Math.min(Math.max(squareX[0],(squareX[0] + currentX)), squareX[2]);			// calculate X value within window (far left x point + how far in we've moved)															// calculate bin value					bin = Math.floor((xVal + binShift) / widthWorld);			// which bin we're in (where in the world + binshift / 1 pulse width					for (j = lastBin; j <= bin; j++) {						poll[j] = ((yValHigh * 0.5) + 0.5);		// set poll to scaled y value					}					lastBin = bin;										lineto(xVal, yValHigh);					lineto(xVal, yValLow);										i++										// if (i == numPulses) break;		// do I need?											// draw lower line					currentX = (i * squareWidth);					xVal = Math.min(Math.max(squareX[0],(squareX[0] + currentX)), squareX[2]);										bin = Math.floor((xVal + binShift) / widthWorld);			// which bin we're in					for (j = lastBin; j <= bin; j++) {						poll[j] = ((yValLow * 0.5) + 0.5);		// set poll to scaled y value					}											lineto(xVal, yValLow);					// lineto(xVal, yValHigh);										lastBin = bin				}				lineto(squareX[2], squareY[2]);			}			send_handles();			break;					case MODE_CLICK:						// clickable and dragable			sketch.glcolor(vfrgb[0],vfrgb[1],vfrgb[2], (vfrgb[3] * 0.2));			var clickableX1 = 0;			var clickableX2 = 0;			with(sketch){				for(i=0; i<poll_resolution; i++){					clickableX1 = ((divisionWorld * i) - aspect);				// running left x coord of box					clickableX2 =  ((divisionWorld * (i+1)) - aspect);			// running right x coord of box					clickableY2 = ((clickableY[i] * 2.) - 1.0);					// running y coord										quad(clickableX1, clickableY2, 0.0, clickableX2, clickableY2, 0.0, clickableX2, -1.0, 0.0, clickableX1, -1.0, 0.0);				}			}						break;	}	refresh();}draw.local = 1;function frgb(r,g,b){	vfrgb[0] = r/255.;	vfrgb[1] = g/255.;	vfrgb[2] = b/255.;	draw();}	function brgb(r,g,b){	bfrgb[0] = r/255.;	bfrgb[1] = g/255.;	bfrgb[2] = b/255.;	draw();}	function handlergb(r,g,b){	handlergb[0] = r/255.;	handlergb[1] = g/255.;	handlergb[2] = b/255.;	draw();}	function onclick(x,y,but,cmd,shift,capslock,option,ctrl){	// lightup(x,y)  to highlight the target clicked	world = sketch.screentoworld(x,y);		switch(mode){	case MODE_SPLINE:								// spline		if (world[0] <= (splineX[0] + 0.01)) {			// selected left side of spline			handleSelected = 0;			splineY[handleSelected] = Math.min(Math.max(-1.0, world[1]), 1.0);		} else if (world[0] >= (splineX[2] - 0.01)) {	// selected right side of spline			handleSelected = 2;			splineY[handleSelected] = Math.min(Math.max(-1.0 ,world[1]), 1.0);		} else {									// selected middle point			handleSelected = 1;			splineX[handleSelected] = world[0];			splineY[handleSelected] = world[1];		}		outlet(1, (splineX[1] / aspect), splineY);		break;	case MODE_SQUARE:								// toggles		if (world[0] <= (squareX[0] + 0.01)) {			// selected left side of square			handleSelected = 0;			squareY[handleSelected] = Math.min(Math.max(-1.0, world[1]), 1.0);		} else if (world[0] >= (squareX[2] - 0.01)) {	// selected right side of square			handleSelected = 2;			squareY[handleSelected] = Math.min(Math.max(-1.0, world[1]), 1.0);		} else {									// selected middle point			handleSelected = 1;			squareX[handleSelected] = world[0];			squareY[handleSelected] = world[1];		}		calculateSquare();		break;	case MODE_CLICK:								// click & editable 		handleSelected = Math.floor(x / pixelWidth);		// which bin is selected		clickableY[handleSelected] = (1 - (y / boxHeight));			// scale and assign y value		break;	}		ondrag(x, y, but, cmd, shift, capslock, option, ctrl);}onclick.local = 1;function ondrag(x, y, but, cmd, shift, capslock, option, ctrl){	var a;	world = sketch.screentoworld(x,y);		switch(mode){		case MODE_SPLINE:								// spline			switch (handleSelected) {		// only adjust selected handle			case 0:				splineY[handleSelected] = Math.min(Math.max(-1.,world[1]), 1.);				break;			case 1:				world[0] = Math.min(Math.max(splineX[0],world[0]),splineX[2]); 	// clip to within outside points				splineX[handleSelected] = world[0];				splineY[handleSelected] = world[1];				break;			case 2:				splineY[handleSelected] = Math.min(Math.max(-1.,world[1]), 1.);				break;			}			outlet(1, (splineX[1] / aspect), splineY);			break;		case MODE_SQUARE:								// toggles			switch (handleSelected) {		// only adjust selected handle			case 0:				squareY[handleSelected] = Math.min(Math.max(-1.,world[1]), 1.);				break;			case 1:				world[0] = Math.min(Math.max(squareX[0],world[0]),squareX[2]); 	// clip to within outside points				squareX[handleSelected] = world[0];				world[1] = Math.min(Math.max(-1.,world[1]),1.); 	// clip to within outside points				squareY[handleSelected] = world[1];				break;			case 2:				squareY[handleSelected] = Math.min(Math.max(-1.,world[1]), 1.);				break;			}			calculateSquare();			break;		case MODE_CLICK:								// click & editable 			handleSelected = Math.floor(x / pixelWidth);					// which bin is selected			y = Math.min(Math.max(0, y), boxHeight);			clickableY[handleSelected] = (1 - (y / boxHeight));		// scale and assign y value			break;	}	draw();	poll_position();}ondrag.local = 1;// UI METHOD: Box is resizedfunction onresize(w,h){	boxWidth = box.rect[2] - box.rect[0];	boxHeight = box.rect[3] - box.rect[1];	aspect = boxWidth/boxHeight;		divisionWorld = (2 * aspect) / poll_resolution;		// width of one division in world coords	pixelWidth = boxWidth / poll_resolution;	calculateSquare();		draw();}onresize.local = 1;/******************************************************************* * PATTR HOOKS *******************************************************************/// PATTR SENDS US STATE DATAfunction setvalueof(){	var i=0;	var arg_index = 0;	var binmodversion = Math.round(arguments[arg_index++]);	if(binmodversion != 2) return;				// check version	vbrgb = [ 	arguments[arg_index],			// get colors				arguments[arg_index+1],				arguments[arg_index+2],				arguments[arg_index+3]];	arg_index += 4;	vfrgb = [ 	arguments[arg_index],				arguments[arg_index+1],				arguments[arg_index+2],				arguments[arg_index+3]];	arg_index += 4;	handlergb = [ arguments[arg_index],				arguments[arg_index+1],				arguments[arg_index+2],				arguments[arg_index+3]];	arg_index += 4;	mode = Math.round(arguments[arg_index++]);	// set mode	multiplier = arguments[arg_index++];		// set scaling	y1 = arguments[arg_index++];				// handle positions	x2 = arguments[arg_index++];	y2 = arguments[arg_index++];	y3 = arguments[arg_index++];	if(mode != MODE_CLICK){		process_handles();	}		if(mode == MODE_CLICK){		poll_resolution = arguments[arg_index++];		for(i=0; i<poll_resolution; i++){			poll[i] = arguments[arg_index++];			clickableY[i] = poll[i] / multiplier;		}		draw();		//poll_position();	}}// PATTR REQUESTS STATE DATAfunction getvalueof(){	var i;	var data = new Array();	var data_index = 0;		data[data_index++] = BINMODUI_VERSION;	// version flag	data[data_index++] = vbrgb[0];			// colors	data[data_index++] = vbrgb[1];	data[data_index++] = vbrgb[2];	data[data_index++] = vbrgb[3];	data[data_index++] = vfrgb[0];	data[data_index++] = vfrgb[1];	data[data_index++] = vfrgb[2];	data[data_index++] = vfrgb[3];	data[data_index++] = handlergb[0];	data[data_index++] = handlergb[1];	data[data_index++] = handlergb[2];	data[data_index++] = handlergb[3];		data[data_index++] = mode;				// gui mode	data[data_index++] = multiplier;		// scaling factor		data[data_index++] = y1;				// handle positions	data[data_index++] = x2;	data[data_index++] = y2;	data[data_index++] = y3;	data[data_index++] = poll_resolution;	// bin values	for(i=0; i<poll_resolution; i++){		data[data_index++] = poll[i];	}	return data;}