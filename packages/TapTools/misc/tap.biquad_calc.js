// Calculate biquad~ coefficients// Tim Place// Copyright © 2004, Electrotap, L.L.C.// From Dodge & Jerse: Q = cf/bw// Notes about using an FFT://	using an FFT with a size of 4096//	22050/2048 (or 44100/4096) = 10.760 Hz per bin//	way too big for lower octaves!/*	omega = 2*PI*cf/sample_rate;	sn = sin(omega);	cs = cos(omega);	alpha = sn/(2*Q);			a0 = alpha;	a1 = 0;	a2 = -alpha;	b0 = 1 + alpha;	b1 = -2*cs;	b2 = 1 - alpha;*//******************************************************************* * SETUP *******************************************************************/// GLOBALSvar type = "bandpass";		// type of filtervar frequency = 1000.0;		// inputvar	q = 5.0;				// inputvar gain = 1.0;				// inputvar a0, a1, b0, b1, b2;		// coefficients (output)var sr = 44100;				// sample-rate// CONFIGURATIONinlets = 3;		// freq, q, gainoutlets = 1;	// list of coefficients// INITIALIZATIONfunction init(){	// set up assistance strings	setinletassist(0, "(float) frequency");	setinletassist(1, "(float) q");	setinletassist(2, "(float) linear gain");	setoutletassist(0,"(float) list of biquad~ coefficients");		// Process Arguments		// argument[0] = name of this javascript file	if(jsarguments.length > 1)		type = jsarguments[1];	if(jsarguments.length > 2)		frequency = jsarguments[2];	if(jsarguments.length > 3)		q = jsarguments[3];	if(jsarguments.length > 4)		gain = jsarguments[4];	}init.local = 1;		// hide the init functioninit();				// run the init function/******************************************************************* * METHODS *******************************************************************/ // process input (floats)function msg_float(value){	if(inlet == 0)		frequency = value;	else if(inlet == 1)		q = value;	else if(inlet == 2)		gain = value;		if(type == "bandpass")		calculate_bandpass_coefficients();	else if (type == "peaknotch")		calculate_peaknotch_coefficients();}// bang: send list of biquad~ coefficientsfunction bang(){	outlet(0, a0, a1, a2, b1, b2);}// Calculate gain-bandpass coefficientsfunction calculate_bandpass_coefficients(){	var omega = 2 * Math.PI * frequency / sr;	var sn = Math.sin(omega);	var cs = Math.cos(omega);	var alpha = sn / (2 * q);	a0 = alpha * gain;	a1 = 0.0;	a2 = -alpha * gain;//	b0 = 1 + alpha;	b1 = -2 * cs;	b2 = 1 - alpha;	bang();}calculate_bandpass_coefficients.local = 1;// Calculate gain-bandpass coefficientsfunction calculate_peaknotch_coefficients(){/*	var A = Math.sqrt(gain);	var omega = 2 * Math.PI * frequency / sr;	var sn = Math.sin(omega);	var cs = Math.cos(omega);	var alpha = sn / (2 * q);	a0 = 1 + alpha * A;	a1 = -2 * cs;	a2 = 1 - alpha * A;//	b0 = 1 + alpha / A;	b1 = -2 * cs;	b2 = 1 - alpha / A;*/	if(gain >= 0)		var A = Math.sqrt(gain);	else		var A = -gain;		var omega = (frequency * Math.PI) / (sr/2);	var sn = Math.sin(omega);	var cs = Math.cos(omega);	var alpha = sn / (q * 2.0);	a0 = (1.0 + alpha * A) / (1.0 + alpha/A);	a1 = (-2.0 * cs) / (1.0 + alpha/A);	a2 = (1.0 - alpha * A) / (1.0 + alpha/A);	b1 = a1;	b2 = (1.0 - alpha/A) / (1.0 + alpha / A);		bang();}calculate_peaknotch_coefficients.local = 1;/******************************************************************* * UTILITIES AND MISCELLANEOUS FUNCTIONS *******************************************************************/  // Clipping utility function clip(value, low_limit, high_limit) { 	if(value < low_limit) 		return low_limit; 	else if(value > high_limit) 		return high_limit; 	else 		return value; } clip.local = 1; 